---
title: 行为型模式
date: 2023-07-23 15:14:29
categories:
- 设计模式
---
# 介绍
行为型模式用于解决“类或对象之间的交互”问题。每一类行为型模式都对应特定的业务场景，算是一种最佳优化。
分为：观察者模式，模版模式，策略模式，职责链模式，状态模式，迭代器模式，访问者模式，备忘录模式，命令模式，解释器模式，中介模式
<!-- more -->

# 分类
## 观察者模式
1. 观察者模式将被观察者和观察者解耦，当被观察者发生改变时，观察者会被通知并进行某些行为。
2. 观察者模式是一种思想，小到代码实现，大到业务架构、组件设计。经典实现有MQ、邮件订阅
3. 实现时有同步阻塞、异步执行、跨进程通知 

## 模版模式
1. 模版方法在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。这让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模版”，包含算法骨架的方法就是“模版方法”，这也是模版方法模式名字的由来。 
2. 提供了代码复用和扩展的作用 
3. 回调类似于模版方法，A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来调用A，这叫做回调 
4. 模版方法依赖于继承机制，重写扩展的方法；回调使用组合方法。组合优于继承。 

## 策略模式
1. 策略模式定义了一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端； 
2. 策略模式用来解耦策略的定义、创建、使用，一个完整的策略就是由这三个部分组成的。  

## 职责链模式
1. 在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，叫做职责链模式 
2. 有两种实现方式，一个是链表；另一个是数组，后者更容易实现

## 状态模式
1. 状态模式是状态机的一种实现方式。状态机有三个部分，状态、事件、动作。事件也称为转移，事件触发状态的转移及动作的执行； 
2. 状态机有三种实现方式 
- 分支逻辑法，利用if-else或switch-case，参照状态转移图，将每一个状态原模原样地直译成代码 
- 查表法，通过二维数组来表示状态转移图，适用于状态很多、状态转移复杂的状态机 
- 状态模式，在分支逻辑法的基础上，为了避免if-else或switch-case，将事件触发的状态转移和动作执行，拆分到不同的状态类。相当于分支逻辑法，一个类可以有多个状态，状态模式则是一个状态一个类 

## 迭代器模式
1. 迭代器模式，也叫游标模式，可以用来遍历集合对象。集合，可以指数组、链表、图、跳表等; 
2. 迭代器模式实现时，一般提供专门的接口和实现类，和集合容器类相区别; 
3. 数组的遍历简单，但是图、链表、树的遍历繁琐或不稳定。迭代器实现了容器和遍历的解耦，迭代器可以提供多种实现方式，对应不同迭代顺序 
4. 迭代时一般要求集合数据不被更新/增删改。也可以通过快照的方式，让更新不影响遍历         

## 访问者模式
1. 访问者模式允许一个或多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及对应代码的复杂性 
2. 一组对象，例如不同类型的文件，本来就对应了一组类。这时想对它们进行多类操作，将这多类操作封装在多个单独的类里面，就会是访问者模式。实现起来挺无聊的，就是把操作单独拉出来了，不写在文件类里面 
3. 代码实现复杂，不推荐使用。 
4. 单分派和双分派 
- 单分派：执行哪个对象的哪个方法，只跟对象的运行时类型有关系 
- 双分派：执行哪个对象的哪个方济，与对象和参数两者的运行时类型有关系 
- 两类的区别就在于参数是在编译时确定类型，还是在运行时确定类型。主流语言都是在编译时确定，也就是写代码时参数类型确定是父类了，即使可能运行时传入了子类

## 备忘录模式
1. 备忘录模式也叫快照模式，在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以使之后恢复对象为先前的状态。模式定义了两部分：一部分是存储副本以便后期恢复；另一部分是要在不违背封装原则的前提下，进行对象的备份和恢复。 
2. 实现时，会在数据对象之外新增一个备忘录对象，保存了数据对象部分信息，数据对象能通过备忘录对象恢复以 前的信息。不违背封装原则，但数据对象还是能感知到数据对象 3.备忘录模式主要用来防丢失，撤销，恢复等。和“备份”有点像，但前者偏重于代码的设计和实现，后者侧重架构 设计和产品设计 

## 命令模式
1. 命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其 他对象），并且能够支持请求（命令）的排队执行，记录日志、撤销等（附加控制）功能。 
2. 实现时，指不直接调用请求的方法，而是将方法和参数封装成一个对象。可以对对象异步处理，放入队列，等等 
3. 在RocketMQ、Redis里面都有用到类似的功能。RocketMQ将请求封装成对象，交给其它线程处理，实现异步处理；Redis将请求封装成对象放入队列，等主线程一次性处理。（有点忘了是RocketMQ还是啥其它的MQ，核心是异步 
4. 用得不多

## 解释器模式
1. 解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法; 
2. 解释器模式没有固定的模版，核心思想是将语法解析的工作拆分到各个小类中，以此避免大而全的解析类。一般的做法是，将语法规则拆分到一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析
3. 用的不多 

## 中介模式
1. 中介模式和中间层的思想类似，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟n个对象交互，现在只需要跟一个中介对象交互,从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。 
2. 用的不多