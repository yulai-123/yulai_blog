---
title: 创建型模式
date: 2023-07-23 15:14:16
categories:
- 设计模式
---
# 介绍
创建型模式用于解决“对象的创建”问题，一般是将复杂对象的创建从业务代码中解耦。复杂对象的创建，流程固定，代码量大。在编写业务代码时，不应该考虑这些代码。
分为：单例模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式
<!-- more -->

# 分类
## 单例模式
1. 单例模式，一个类只允许创建一个对象，这个类就是一个单例类
2. 单例的实现
- 饿汉式：在类加载时期，就已经将实例静态初始化好了
- 懒汉式：支持延迟加载，在使用时才初始化
- 双重检测：通过两重检测，第一次检测避免不必要的加锁，第二次检测判断是否实例化，实现时挺有趣的
- 静态内部类：依赖于语言自身的静态内部类语法实现
- 权举

3. 单例模式能够保证全局只有唯一对象，避免内存资源浪费，部分资源也的确要保证全局唯一。但单例模式使得全局使用同一个实例
- 单例对OOP特性的支持不友好
- 单例会隐藏类之间的依赖关系
- 单例对代码的扩展性不友好
- 单例对代码的可测试性不友好
- 单例不支持有参数的构造函数      

## 工厂方法模式
1. 当创建逻辑比较复杂时，可以使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离
2. 工厂方法模式在实现时有两种方式：简单工厂模式和工厂方法模式
- 简单工厂模式：将多个对象的创建逻辑放到一个工厂类中
- 工厂方法模式：当对象的创建逻辑复杂时，为了避免设计一个过于庞大的简单工厂类，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中，同时提供一个总的工厂类，用来调用各个子工厂类创建对应的实例

3. 作用：
- 封装变化，创建逻辑的变更对调用者透明
- 代码复用：复用创建逻辑
- 隔离复杂性：调用者不需要关注创建逻辑
- 控制复杂度：将创建代码从调用函数抽离出来，让原函数更加简洁                    

## 抽象工厂模式
1. 也是一种创建对象的工厂模式，代码实现类似工厂方法模式。但是工厂的子类实现了多类接口，提供了多个创建方法。
简单说，工厂方法中子类只会提供一个create方法，抽象工厂中一个子类提供多个create方法，创建不同类型的方法，主要目的是复用同一个子类，避免创建大量子类，感觉只是工厂方法模式的变形，不需要特别关注。 

## 建造者模式
1. 建造者模式，当一个类的创建比较复杂时，可以将这类创建封装在专门的 建造者类中，隔离创建代码和业务代码，提高代码的可读性 
2. 工厂模式是用来创建不同类型但功能相关的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过函数封装复杂创建流程，简化业务代码逻辑               

## 原型模式
1. 如果对象的创建成本比较大，同一个类的不同对象之间比较像，我们可以利用已经存在的对象，通过复制的方式创建新的对象，可以节省创建时间 
2. 复制有浅拷贝和深拷贝两种方式，前者会共享底层数据，有数据被修改相互影响的风险。 
3. 原型模式主要用于节省对象的创建时间，比如数据中部分数据来自于远程接口或硬盘，再次读取比较耗时，利用原型模式直接使用已有数据，避免再次获取的耗时 
